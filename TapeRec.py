#!/usr/bin/env python3

import numpy as np
import cv2
import math
from enum import Enum

class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__hsv_threshold_hue = [0.0, 0.0]
        self.__hsv_threshold_saturation = [0.0, 36.06060606060606]
        self.__hsv_threshold_value = [217.85071942446044, 255.0]

        self.hsv_threshold_output = None

        self.__find_contours_input = self.hsv_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__convex_hulls_contours = self.find_contours_output

        self.convex_hulls_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step HSV_Threshold0:
        self.__hsv_threshold_input = source0
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)

        # Step Find_Contours0:
        self.__find_contours_input = self.hsv_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        # Step Convex_Hulls0:
        self.__convex_hulls_contours = self.find_contours_output
        (self.convex_hulls_output) = self.__convex_hulls(self.__convex_hulls_contours)


    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod
    def __convex_hulls(input_contours):
        """Computes the convex hulls of contours.
        Args:
            input_contours: A list of numpy.ndarray that each represent a contour.
        Returns:
            A list of numpy.ndarray that each represent a contour.
        """
        output = []
        for contour in input_contours:
            output.append(cv2.convexHull(contour))
        return output




# Self written code
cap = cv2.VideoCapture(1)
eyes = GripPipeline()

class Tape:
    def __init__(self, cnt):
        self.center = None
        self.angle = None
        self.area = None
        self.vertices =  np.int0(cv2.boxPoints(cv2.minAreaRect(cnt)))
        self.sortedVerticesX = []
        self.sortedVerticesY = []
        self.contour = cnt

    def getCenter(self):
        M = cv2.moments(self.contour)
        if M['m00'] != 0:
            self.center = (int(M['m10']/M['m00']), int(M['m01']/M['m00']))
            return self.center
        return (0,0)

    def getArea(self):
        M = cv2.moments(self.contour)
        self.area = M['m00']
        return self.area

    def getSortedVerticesX(self):
        def x(list):
            return list[1]
        self.sortedVerticesX = list(sorted(self.vertices, key = x))
        return self.sortedVerticesX

    def getSortedVerticesY(self):
        def Y(list):
            return list[1]
        self.sortedVerticesY = sorted(self.vertices, key = Y)
        return self.sortedVerticesY

    def getVertices(self):
        return self.vertices

    def getCenterLine(self, img):
        rows,cols = img.shape[:2]
        [vx,vy,x,y] = cv2.fitLine(self.contour, cv2.DIST_L2,0,0.01,0.01)
        lefty = int((-x*vy/vx) + y)
        righty = int(((cols-x)*vy/vx)+y)
        return [rows, cols, lefty, righty]

    def getEquation(self, img):
        rightPt = [self.getCenterLine(img)[1]-1, self.getCenterLine(img)[3]]
        leftPt = [0,self.getCenterLine(img)[2]]
        a = -(self.getCenterLine(img)[3]-self.getCenterLine(img)[2])
        b = self.getCenterLine(img)[1]-1
        c = self.getCenterLine(img)[3]*(self.getCenterLine(img)[1]-1)
        return [a,b,c]

def findIntercept(tape1, tape2, img):
    y = 0
    if ((tape1.getEquation(img)[0]*tape2.getEquation(img)[1])-(tape1.getEquation(img)[1]*tape2.getEquation(img)[0]))!=0:
        y = ((tape1.getEquation(img)[0]*tape2.getEquation(img)[2])-(tape1.getEquation(img)[2]*tape2.getEquation(img)[0]))/((tape1.getEquation(img)[0]*tape2.getEquation(img)[1])-(tape1.getEquation(img)[1]*tape2.getEquation(img)[0]))
    return y

def findCenter(tape1, tape2):
    M1 = cv2.moments(tape1.contour)
    M2 = cv2.moments(tape2.contour)
    if M1['m00'] != 0 and M2['m00'] != 0:
        c1x, c1y = int(M1['m10']/M1['m00']), int(M1['m01']/M1['m00'])
        c2x, c2y = int(M2['m10']/M2['m00']), int(M2['m01']/M2['m00'])
        centerX = int((c1x + c2x)/2)
        centerY = int((c1y + c2y)/2)
        return [centerX, centerY]
    return [0,0]

while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    uselessThing, shape = cap.read()
    unneeded, boundedImg = cap.read()

    # access the generated code
    eyes.process(frame)

    tapeNum = 0
    numOftape = len(eyes.convex_hulls_output)
    font = cv2.FONT_HERSHEY_SIMPLEX
    boundedImg = cv2.putText(boundedImg,'# of tapes: '+str(numOftape),(10,12), font, 0.5,(255,255,255),1,cv2.LINE_AA)
    tapes = []
    sortedTapes = []
    groups = []

    for borders in eyes.convex_hulls_output:
        tape = Tape(borders)
        tapes.append(tape)
        tapeNum += 1
        boundedImg = cv2.drawContours(boundedImg,[tape.vertices],0,(0,0,255),2)
            # Gets statistics on the rectangle
        # boundedImg=cv2.circle(boundedImg, tape.getCenter(), 5, (0,255,0), thickness=-1, lineType=8, shift=0)
        boundedImg = cv2.putText(boundedImg,'Tape#: '+str(tapeNum)+', Center at: '+str(tape.getCenter()[0])+','+str(tape.getCenter()[1]),(tape.vertices[0][0],tape.vertices[0][1]), font, 0.4,(255,255,255),1,cv2.LINE_AA)
        def getLeftCorner(list):
            return list.getSortedVerticesX()[0][1]
        sortedTapes = sorted(tapes, key = getLeftCorner)
            # Grouping
        for i in range(len(tapes)):
            for j in range(len(tapes)):
                if (sortedTapes[i].getCenter()!=sortedTapes[j].getCenter()) and findIntercept(sortedTapes[i], sortedTapes[j], boundedImg) < findCenter(sortedTapes[i], sortedTapes[j])[1] :
                    groups.append([sortedTapes[i], sortedTapes[j]])
                    break
        list(set(tapes))


        # Finding the middle point only if there are 2 tapes (will be updated later)
        for target in groups:
            boundedImg =  cv2.rectangle(boundedImg,(target[0].getSortedVerticesX()[2][0],target[0].getSortedVerticesX()[0][1]),(target[1].getSortedVerticesY()[2][0],target[1].getSortedVerticesY()[3][1]),(0,255,0),3)
                # boundedImg = cv2.line(boundedImg,(strip.getCenterLine(boundedImg)[1]-1,strip.getCenterLine(boundedImg)[3]),(0,strip.getCenterLine(boundedImg)[2]),(0,255,0),2)

    # multiple image to compare effect
    cv2.imshow('frame',frame)
    cv2.imshow('frame2',shape)
    cv2.imshow('frame3',boundedImg)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break


# When everything done, release the capture
cap.release()
cv2.destroyAllWindows()
